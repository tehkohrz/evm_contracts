// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./@openzeppelin/contracts/utils/Strings.sol";
import "./@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./@openzeppelin/contracts/security/Pausable.sol";

contract OrdersRelayer is Ownable, Pausable {
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableSet for EnumerableSet.AddressSet;

    struct Order {
        string id; // order id generated by carbon
        string market;
        Side side;
        uint256 price;
        uint256 quantity; // Originally int will have extra decimal zeros
        Status status;
        OrderType orderType;
        TimeInForce timeInForce;
        uint256 avgFilledPrice;
        bool isReduceOnly;
        address evmCreator; // evm address of the creator
    }

    struct MsgOrderUpdate {
        string orderKey;
        string orderId;
        uint256 avgFilledPrice;
        Status status;
    }

    struct PositionQuery {
        string market;
        address caller;
        string fnSigature;
    }

    struct MsgPositionQueryRes {
        address evmAddress;
        string market;
        string carbonAddress;
        int256 lots;
        uint256 entryPrice;
        int256 realizedPnl;
        string allocatedMarginDenom;
        uint256 allocatedMarginAmount;
        uint256 openedBlockHeight;
    }

    struct OrderQuery {
        address caller;
        string fnSigature;
    }

    struct MsgOrderQueryResponse {
        string orderKey;
        Order order;
    }

    enum Status {
        Unprocessed,
        Pending,
        Closed,
        Cancelled,
        Open
    }

    enum TimeInForce {
        FOK,
        GTC,
        IOC
    }

    enum Side {
        Buy,
        Sell
    }

    enum OrderType {
        Limit,
        Market
    }

    // =============Storage==============
    // @notice Id of the contract to easier identify the contract and account of multiple contract for different kinds of orders
    string public contractId;
    //@notice Flag to indicate if the contract is active, for info only all methods are blocked by pausable
    bool public isActive;
    // @notice Sequence number to generate a unique order id
    uint256 internal _orderSequence = 0;
    // @notice Number of decimals for conversion of all integer values type decimals
    uint64 public decimals;

    // @notice Mapping of orderKey(evm) to orders pending processing by carbon
    mapping(string => Order) public pendingOrders;
    // @notice Mapping of orderKey to callback request for update after order processed
    mapping(string => OrderQuery) public orderCreationCallback;
    // @notice Set of orderkeys used to track and purge the map to prevent bloat
    EnumerableSet.Bytes32Set pendingOrdersKeys;

    // @notice Mapping of account address to position query request
    mapping(address => PositionQuery) public positionQueries;
    // @notice Set of postionQueryKeys used to track and purge the map to prevent bloat
    EnumerableSet.AddressSet positionQueryKeys;

    // @notice Mapping of orderKey to order query request
    mapping(string => OrderQuery) public orderQueries;
    // @notice Set of orderQuerykeys used to track and purge the map to prevent bloat
    EnumerableSet.Bytes32Set orderQueryKeys;

    // =============Events================
    // @param creator - evm address of the order creator
    // @param market - market name of the order
    // @param side - side of the order in uint8
    // @param price - price of the order to be converted from int to dec
    // @param quantity - quantity of the order to be converted from int to dec
    // @param status - status of the order in uint8
    // @param orderType - order type of the order in uint8
    // @param timeInForce - time in force of the order in uint8
    // @param isReduceOnly - reduce only flag of the order
    // @param decimals - number of decimals for conversion of all int to dec
    // @param contractId - id of the contract for carbon to track the contract to update
    event CreateOrder(
        string orderKey,
        address creator,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        bool isReduceOnly,
        uint64 decimals,
        string contractId
    );

    // @notice event to update the finalised order details as a back up for callback
    // @param orderKey - evmKey of the order
    // @param order - update order after processed by carbon broker
    event FinalisedOrder(string orderKey, Order order);

    // @notice event for position query request to carbon
    // @param market - market name the position is in
    // @param account - evm address of the position's account
    // @param contractId - id of the contract for carbon to track the contract to update
    event PositionQueryRequest(
        string market,
        address accountAddress,
        string contractId
    );

    // @notice event for position query response as a back up for callback
    event PositionQueryResponse(MsgPositionQueryRes msg);

    // @param evmAddr - addresss of the position queried
    // @param errPos - fields of the position queries for easier reference to query
    // @param error - error message from evm integration of order module
    event PositionError(
        address evmAddr,
        MsgPositionQueryRes errPos,
        string error
    );

    // @notice event for order query request to carbon
    // @param orderKey - evmKey of the order
    event OrderQueryRequest(string orderKey, string contractId);

    // @param orderKey - evmKey of the order
    // @param order - order that has failed and not processed by carbon broker
    // @param error - error message from evm integration of order module
    event OrderError(string orderKey, Order errOrder, string error);

    constructor(string memory contractId_, uint64 decimals_) {
        contractId = contractId_;
        decimals = decimals_;
        isActive = true;
    }

    // @notice generates a new FOK order to be relayed to carbon broker
    // @dev emits a create order event captured by order module of carbon
    // @params market_ - market name the order is to
    // @params side_ - side of the order in uint8
    // @params quantity_ - quantity of the order
    // @params orderType_ - limit or market order in uint8
    // @params price_ - price of the order
    // @params isReduceOnly_ - reduce only flag of the order
    // @params callbackSig_ - signature of the callback function of the client's contract for updating of processed order
    function createOrder(
        string calldata market_,
        Side side_,
        uint256 quantity_,
        OrderType orderType_,
        uint256 price_,
        bool isReduceOnly_,
        string calldata callbackSig_
    ) external whenNotPaused {
        require(tx.origin != owner(), "Owner cannot create order"); // Prevent tx.origin exploit

        Order memory newOrder;
        string memory orderKey = generateOrderKey();

        address creator_ = tx.origin; // to use tx.origin or _msg.Sender? //dklog

        newOrder.id = ""; // This is the id generated by carbon
        newOrder.evmCreator = creator_;
        newOrder.market = market_;
        newOrder.side = side_;
        newOrder.price = price_;
        newOrder.quantity = quantity_;
        newOrder.status = Status.Pending;
        newOrder.orderType = orderType_;
        newOrder.timeInForce = TimeInForce.GTC; //! DKLOG for testing change back to FOK
        newOrder.isReduceOnly = isReduceOnly_;

        // add the order into the mapping and keys set
        pendingOrders[orderKey] = newOrder;
        bytes32 orderKeyBytes = keccak256(abi.encodePacked(orderKey));
        EnumerableSet.add(pendingOrdersKeys, orderKeyBytes);

        // add to the callback map if signature is provided
        if (bytes(callbackSig_).length > 0) {
            // order id field is irrelevant here
            orderCreationCallback[orderKey] = OrderQuery(
                _msgSender(),
                callbackSig_
            );
        }

        emit CreateOrder(
            orderKey,
            creator_,
            newOrder.market,
            newOrder.side,
            newOrder.price,
            newOrder.quantity,
            newOrder.status,
            newOrder.orderType,
            newOrder.timeInForce,
            newOrder.isReduceOnly,
            decimals,
            contractId
        );
    }

    // @notice process the order updates either via callback or event
    // @dev emits a finalised order event if callback fn not provided or failed
    function updateOrderStatus(
        string calldata orderKey_,
        string calldata orderId_,
        uint256 avgFilledPrice_,
        Status status_
    ) internal onlyOwner whenNotPaused returns (bool error) {
        // Get the pending order
        Order storage order = pendingOrders[orderKey_];
        if (order.quantity == 0) {
            return true;
        }

        // Update the pending order and emit the finalised order details
        order.avgFilledPrice = avgFilledPrice_;
        order.id = orderId_;
        order.status = status_;

        // Callback to the caller or emit finalised order event
        orderCallback(order, orderKey_);
        // Remove pending order from the store
        delete pendingOrders[orderKey_];
        EnumerableSet.remove(
            pendingOrdersKeys,
            keccak256(abi.encodePacked(orderKey_))
        );
        return false;
    }

    // @notice batch update call made by carbon broker to update all processed orders
    function updateAllOrdersStatus(
        MsgOrderUpdate[] calldata orderUpdates_
    ) external onlyOwner whenNotPaused returns (string memory error) {
        for (uint i = 0; i < orderUpdates_.length; i += 1) {
            bool err = updateOrderStatus(
                orderUpdates_[i].orderKey,
                orderUpdates_[i].orderId,
                orderUpdates_[i].avgFilledPrice,
                orderUpdates_[i].status
            );
            if (err) {
                return "Order could not be updated";
            }
        }
        return "";
    }

    // @notice encodes the update and makes the callback to the client contract
    function orderCallback(
        Order storage order,
        string calldata orderKey
    ) internal {
        bool noEmitEvent = false;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                order,
                orderKey
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey];
        }

        if (!noEmitEvent) {
            emit FinalisedOrder(orderKey, order);
        }
    }

    // @notice delete the pending order in the event of an error before carbon processes
    // the order. Proceeds to callback or emit event with updates.
    function deleteErrOrder(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner whenNotPaused {
        bool noEmitEvent = false;

        Order storage errOrder = pendingOrders[orderKey_];
        errOrder.status = Status.Unprocessed;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey_];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            errOrder.id = error_;
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                errOrder,
                orderKey_
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey_];
        }

        if (!noEmitEvent) {
            emit OrderError(orderKey_, errOrder, error_);
        }

        // purge the pending order and update with unprocessed status
        delete pendingOrders[orderKey_];
        EnumerableSet.remove(
            pendingOrdersKeys,
            keccak256(abi.encodePacked(orderKey_))
        );
    }

    // @notice registers the position query request from the client and saves the required details
    // @param accountAddress_ - evm address of the position to query
    // @param market_ - market name of the position to query
    // @param callbackSig_ - signature of the callback function to return response
    function queryAddressPosition(
        address accountAddress_,
        string calldata market_,
        string calldata callbackSig_
    ) external whenNotPaused {
        PositionQuery memory positionQuery;
        positionQuery.market = market_;
        positionQuery.caller = _msgSender();
        positionQuery.fnSigature = callbackSig_;

        positionQueries[accountAddress_] = positionQuery;
        EnumerableSet.add(positionQueryKeys, accountAddress_);

        emit PositionQueryRequest(market_, accountAddress_, contractId);
    }

    // @notice Called by carbon to relay the response after processing query
    function respondToPositionQuery(
        MsgPositionQueryRes calldata msg_
    ) external onlyOwner whenNotPaused {
        PositionQuery memory queryReq = positionQueries[msg_.evmAddress];
        bool noEmitEvent = true;
        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                msg_
            );

            // no need return value of call since it is a fire and forget but send an event so the caller
            // can still check for the position in another way
            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }
        if (!noEmitEvent) {
            emit PositionQueryResponse(msg_);
        }
        positionQueries[msg_.evmAddress] = queryReq;
        // remove the query from the store
        delete positionQueries[msg_.evmAddress];
        EnumerableSet.remove(positionQueryKeys, msg_.evmAddress);
    }

    // @notice Responds to the position query with an error message in carbon address field
    // @dev emits a position error event if callback fn not provided or failed
    // @param evmAddr_ - evm address of the position to query
    // @param error_ - error message returned from evm integration of order module
    function deletePositionQuery(
        address evmAddr_,
        string calldata error_
    ) external onlyOwner {
        bool noEmitEvent = false;
        // purge the pending order and update with unprocessed status
        PositionQuery storage queryReq = positionQueries[evmAddr_];

        // Callback expecting the same format, send back the format with error
        MsgPositionQueryRes memory errPos = MsgPositionQueryRes(
            evmAddr_,
            queryReq.market,
            error_,
            0,
            0,
            0,
            "",
            0,
            0
        );
        // Check for callback request
        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                errPos
            );
            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }

        if (!noEmitEvent) {
            emit PositionError(evmAddr_, errPos, error_);
        }

        EnumerableSet.remove(positionQueryKeys, evmAddr_);
        delete positionQueries[evmAddr_];
    }

    // @notice registers the order query request from the client and saves the required details
    // @dev mapping of the evm orderKey is persisted in the store of carbon
    // @param orderKey_ - evm key of the order to query
    // @param callbackSig_ - signature of the callback function to return response
    function queryOrder(
        string calldata orderKey_,
        string calldata callbackSig_
    ) external whenNotPaused {
        OrderQuery memory orderQuery;
        orderQuery.caller = _msgSender();
        orderQuery.fnSigature = callbackSig_;

        orderQueries[orderKey_] = orderQuery;
        EnumerableSet.add(
            orderQueryKeys,
            keccak256(abi.encodePacked(orderKey_))
        );

        emit OrderQueryRequest(orderKey_, contractId);
    }

    // @notice Called by carbon to relay the order response after processing query
    function respondToOrderQuery(
        MsgOrderQueryResponse memory msg_
    ) external whenNotPaused onlyOwner {
        OrderQuery memory queryReq = orderQueries[msg_.orderKey];

        // check if there is a callback provided
        bool noEmitEvent = true;
        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                msg_.order,
                msg_.orderKey
            );

            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }
        if (!noEmitEvent) {
            emit FinalisedOrder(msg_.orderKey, msg_.order);
        }

        delete orderQueries[msg_.orderKey];
        EnumerableSet.add(
            orderQueryKeys,
            keccak256(abi.encodePacked(msg_.orderKey))
        );
    }

    // @notice Responds to the order query with an error message in order id
    // @dev emits a position error event if callback fn not provided or failed
    // @param evmAddr_ - evm address of the position to query
    // @param error_ - error message returned from evm integration of order module
    function deleteOrderQuery(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner {
        OrderQuery memory queryReq = orderQueries[orderKey_];
        bool noEmitEvent = false;

        // Form error order
        Order memory errOrder;
        errOrder.id = error_;

        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                errOrder,
                orderKey_
            );

            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }
        if (!noEmitEvent) {
            emit FinalisedOrder(orderKey_, errOrder);
        }

        delete orderQueries[orderKey_];
        EnumerableSet.add(
            orderQueryKeys,
            keccak256(abi.encodePacked(orderKey_))
        );
    }

    // @notice Hash function to generate a uuid for the order
    // @dev  Uses a combination of contractId and order seq number within the contract
    function generateOrderKey() private returns (string memory) {
        bool isCollision = true;
        string memory stringId;
        // generate hashId until no collisions found
        while (isCollision) {
            bytes32 hashedId = keccak256(
                abi.encodePacked(contractId, _orderSequence)
            );
            stringId = Strings.toHexString(uint256(hashedId), 32);
            isCollision = false;

            // Check existing pending store for key collisions
            Order memory existingOrder = pendingOrders[stringId];
            if (existingOrder.status != Status.Unprocessed) {
                isCollision = true;
            }
        }
        _orderSequence += 1;
        return stringId;
    }

    // @notice purge all the lingering pending orders and callbacks from map and key set
    function purgePendingOrderStore() external onlyOwner {
        bytes32[] memory keysArr = EnumerableSet.values(pendingOrdersKeys);
        for (uint i = 0; i < keysArr.length; i += 1) {
            delete pendingOrders[string(abi.encodePacked(keysArr[i]))];
            delete orderCreationCallback[string(abi.encodePacked(keysArr[i]))];
            EnumerableSet.remove(pendingOrdersKeys, keysArr[i]);
        }
    }

    // @notice purge all the lingering order queries from map and set
    function purgeOrderQueriesStore() external onlyOwner {
        bytes32[] memory keysArr = EnumerableSet.values(orderQueryKeys);
        for (uint i = 0; i < keysArr.length; i += 1) {
            delete orderQueries[string(abi.encodePacked(keysArr[i]))];
            EnumerableSet.remove(orderQueryKeys, keysArr[i]);
        }
    }

    // @notice purge all the lingering position queries from map and set
    function purgePositionQueriesStore() external onlyOwner {
        address[] memory keysArr = EnumerableSet.values(positionQueryKeys);
        for (uint i = 0; i < keysArr.length; i += 1) {
            delete positionQueries[keysArr[i]];
            EnumerableSet.remove(positionQueryKeys, keysArr[i]);
        }
    }

    // @ntoice deactivates the contract and updates the public active flag
    function deActivateContract() external onlyOwner {
        _pause();
        isActive = false;
    }

    // @ntoice reactivates the contract and updates the public active flag
    function activateContract() external onlyOwner {
        _unpause();
        isActive = true;
    }

    //todo: remove after tests have been written DKLOG
    function ping() public pure returns (string memory) {
        return "pong";
    }
}
