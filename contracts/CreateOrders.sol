// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./@openzeppelin/contracts/utils/Strings.sol";
import "./@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./@openzeppelin/contracts/security/Pausable.sol";

contract CreateOrders is Ownable, Pausable {
    using EnumerableSet for EnumerableSet.Bytes32Set;

    struct Order {
        string id; // order id generated by carbon
        string market;
        Side side;
        uint256 price;
        uint256 quantity; // Originally int will have extra decimal zeros
        Status status;
        OrderType orderType;
        TimeInForce timeInForce;
        uint256 avgFilledPrice;
        bool isReduceOnly;
        address evmCreator; // evm address of the creator
    }

    struct MsgOrderUpdate {
        string orderKey;
        string orderId;
        uint256 avgFilledPrice;
        Status status;
    }

    struct OrderQuery {
        address caller;
        string fnSigature;
    }

    enum Status {
        Unprocessed,
        Pending,
        Closed,
        Cancelled,
        Open
    }

    enum TimeInForce {
        FOK,
        GTC,
        IOC
    }

    enum Side {
        Buy,
        Sell
    }

    enum OrderType {
        Limit,
        Market
    }

    // =============Storage==============
    // @notice Id of the contract to easier identify the contract and account of multiple contract for different kinds of orders
    string public contractId;
    //@notice Flag to indicate if the contract is active, for info only all methods are blocked by pausable
    bool public isActive;
    // @notice Sequence number to generate a unique order id
    uint256 internal _orderSequence = 0;
    // @notice Number of decimals for conversion of all integer values type decimals
    uint64 public decimals;

    // @notice Mapping of orderKey(evm) to orders pending processing by carbon
    mapping(string => Order) public pendingOrders;
    // @notice Mapping of orderKey to callback request for update after order processed
    mapping(string => OrderQuery) public orderCreationCallback;
    // @notice Set of orderkeys used to track and purge the map to prevent bloat
    EnumerableSet.Bytes32Set pendingOrdersKeys;

    // =============Events================
    // @param creator - evm address of the order creator
    // @param market - market name of the order
    // @param side - side of the order in uint8
    // @param price - price of the order to be converted from int to dec
    // @param quantity - quantity of the order to be converted from int to dec
    // @param status - status of the order in uint8
    // @param orderType - order type of the order in uint8
    // @param timeInForce - time in force of the order in uint8
    // @param isReduceOnly - reduce only flag of the order
    // @param decimals - number of decimals for conversion of all int to dec
    // @param contractId - id of the contract for carbon to track the contract to update
    event CreateOrder(
        string orderKey,
        address creator,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        bool isReduceOnly,
        uint64 decimals,
        string contractId
    );

    // @notice event to update the finalised order details as a back up for callback
    // @param orderKey - evmKey of the order
    // @param order - update order after processed by carbon broker
    event FinalisedOrder(string orderKey, Order order);

    // @param orderKey - evmKey of the order
    // @param order - order that has failed and not processed by carbon broker
    // @param error - error message from evm integration of order module
    event OrderError(string orderKey, Order errOrder, string error);

    constructor(string memory contractId_, uint64 decimals_) {
        contractId = contractId_;
        decimals = decimals_;
        isActive = true;
    }

    // @notice generates a new FOK order to be relayed to carbon broker
    // @dev emits a create order event captured by order module of carbon
    // @params market_ - market name the order is to
    // @params side_ - side of the order in uint8
    // @params quantity_ - quantity of the order
    // @params orderType_ - limit or market order in uint8
    // @params price_ - price of the order
    // @params isReduceOnly_ - reduce only flag of the order
    // @params callbackSig_ - signature of the callback function of the client's contract for updating of processed order
    function createOrder(
        string calldata market_,
        Side side_,
        uint256 quantity_,
        OrderType orderType_,
        uint256 price_,
        bool isReduceOnly_,
        string calldata callbackSig_
    ) external whenNotPaused {
        require(tx.origin != owner(), "Owner cannot create order"); // Prevent tx.origin exploit

        Order memory newOrder;
        string memory orderKey = generateOrderKey();

        address creator_ = tx.origin; // to use tx.origin or _msg.Sender? //dklog

        newOrder.id = ""; // This is the id generated by carbon
        newOrder.evmCreator = creator_;
        newOrder.market = market_;
        newOrder.side = side_;
        newOrder.price = price_;
        newOrder.quantity = quantity_;
        newOrder.status = Status.Pending;
        newOrder.orderType = orderType_;
        newOrder.timeInForce = TimeInForce.GTC; //! DKLOG for testing change back to FOK
        newOrder.isReduceOnly = isReduceOnly_;

        // add the order into the mapping and keys set
        pendingOrders[orderKey] = newOrder;
        bytes32 orderKeyBytes = keccak256(abi.encodePacked(orderKey));
        EnumerableSet.add(pendingOrdersKeys, orderKeyBytes);

        // add to the callback map if signature is provided
        if (bytes(callbackSig_).length > 0) {
            // order id field is irrelevant here
            orderCreationCallback[orderKey] = OrderQuery(
                _msgSender(),
                callbackSig_
            );
        }

        emit CreateOrder(
            orderKey,
            creator_,
            newOrder.market,
            newOrder.side,
            newOrder.price,
            newOrder.quantity,
            newOrder.status,
            newOrder.orderType,
            newOrder.timeInForce,
            newOrder.isReduceOnly,
            decimals,
            contractId
        );
    }

    // @notice process the order updates either via callback or event
    // @dev emits a finalised order event if callback fn not provided or failed
    function updateOrderStatus(
        string calldata orderKey_,
        string calldata orderId_,
        uint256 avgFilledPrice_,
        Status status_
    ) internal onlyOwner whenNotPaused returns (bool error) {
        // Get the pending order
        Order storage order = pendingOrders[orderKey_];
        if (order.quantity == 0) {
            return true;
        }

        // Update the pending order and emit the finalised order details
        order.avgFilledPrice = avgFilledPrice_;
        order.id = orderId_;
        order.status = status_;

        // Callback to the caller or emit finalised order event
        orderCallback(order, orderKey_);
        // Remove pending order from the store
        delete pendingOrders[orderKey_];
        EnumerableSet.remove(
            pendingOrdersKeys,
            keccak256(abi.encodePacked(orderKey_))
        );
        return false;
    }

    // @notice batch update call made by carbon broker to update all processed orders
    function updateAllOrdersStatus(
        MsgOrderUpdate[] calldata orderUpdates_
    ) external onlyOwner whenNotPaused returns (string memory error) {
        for (uint i = 0; i < orderUpdates_.length; i += 1) {
            bool err = updateOrderStatus(
                orderUpdates_[i].orderKey,
                orderUpdates_[i].orderId,
                orderUpdates_[i].avgFilledPrice,
                orderUpdates_[i].status
            );
            if (err) {
                return "Order could not be updated";
            }
        }
        return "";
    }

    // @notice encodes the update and makes the callback to the client contract
    function orderCallback(
        Order storage order,
        string calldata orderKey
    ) internal {
        bool noEmitEvent = false;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                order,
                orderKey
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey];
        }

        if (!noEmitEvent) {
            emit FinalisedOrder(orderKey, order);
        }
    }

    // @notice delete the pending order in the event of an error before carbon processes
    // the order. Proceeds to callback or emit event with updates.
    function deleteErrOrder(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner whenNotPaused {
        bool noEmitEvent = false;

        Order storage errOrder = pendingOrders[orderKey_];
        errOrder.status = Status.Unprocessed;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey_];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            errOrder.id = error_;
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                errOrder,
                orderKey_
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey_];
        }

        if (!noEmitEvent) {
            emit OrderError(orderKey_, errOrder, error_);
        }

        // purge the pending order and update with unprocessed status
        delete pendingOrders[orderKey_];
        EnumerableSet.remove(
            pendingOrdersKeys,
            keccak256(abi.encodePacked(orderKey_))
        );
    }

    // @notice Hash function to generate a uuid for the order
    // @dev  Uses a combination of contractId and order seq number within the contract
    function generateOrderKey() private returns (string memory) {
        bool isCollision = true;
        string memory stringId;
        // generate hashId until no collisions found
        while (isCollision) {
            bytes32 hashedId = keccak256(
                abi.encodePacked(contractId, _orderSequence)
            );
            stringId = Strings.toHexString(uint256(hashedId), 32);
            isCollision = false;

            // Check existing pending store for key collisions
            Order memory existingOrder = pendingOrders[stringId];
            if (existingOrder.status != Status.Unprocessed) {
                isCollision = true;
            }
        }
        _orderSequence += 1;
        return stringId;
    }

    // @notice purge all the lingering pending orders and callbacks from map and key set
    function purgePendingOrderStore() external onlyOwner {
        bytes32[] memory keysArr = EnumerableSet.values(pendingOrdersKeys);
        for (uint i = 0; i < keysArr.length; i += 1) {
            delete pendingOrders[string(abi.encodePacked(keysArr[i]))];
            delete orderCreationCallback[string(abi.encodePacked(keysArr[i]))];
            EnumerableSet.remove(pendingOrdersKeys, keysArr[i]);
        }
    }

    // @ntoice deactivates the contract and updates the public active flag
    function deActivateContract() external onlyOwner {
        _pause();
        isActive = false;
    }

    // @ntoice reactivates the contract and updates the public active flag
    function activateContract() external onlyOwner {
        _unpause();
        isActive = true;
    }

    //todo: remove after tests have been written DKLOG
    function ping() public pure returns (string memory) {
        return "pong";
    }
}
