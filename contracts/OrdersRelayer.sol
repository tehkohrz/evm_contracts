// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./@openzeppelin/contracts/utils/Strings.sol";
import "./@openzeppelin/contracts/utils/structs/EnumerableMap.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./@openzeppelin/contracts/security/Pausable.sol";

contract OrdersRelayer is Ownable, Pausable {
    struct Order {
        string id; // order id generated by carbon
        string market;
        Side side;
        uint256 price;
        uint256 quantity; // Originally int will have extra decimal zeros
        Status status;
        OrderType orderType;
        TimeInForce timeInForce;
        uint256 avgFilledPrice;
        bool isReduceOnly;
        address evmCreator; // evm address of the creator
    }

    struct MsgOrderUpdate {
        string orderKey;
        string orderId;
        uint256 avgFilledPrice;
        Status status;
    }

    struct PositionQuery {
        string market;
        address caller;
        string fnSigature;
    }

    struct MsgPositionQueryRes {
        address evmAddress;
        string market;
        string carbonAddress;
        int256 lots;
        uint256 entryPrice;
        int256 realizedPnl;
        string allocatedMarginDenom;
        uint256 allocatedMarginAmount;
        uint256 openedBlockHeight;
    }

    struct OrderQuery {
        address caller;
        string fnSigature;
    }

    struct MsgOrderQueryResponse {
        string orderKey;
        Order order;
    }

    enum Status {
        Unprocessed,
        Pending,
        Closed,
        Cancelled,
        Open
    }

    enum TimeInForce {
        FOK,
        GTC,
        IOC
    }

    enum Side {
        Buy,
        Sell
    }

    enum OrderType {
        Limit,
        Market
    }

    // =============Storage==============
    // @notice Id of the contract to easier identify the contract and account of multiple contract for different kinds of orders
    string public contractId;
    // @notice Sequence number to generate a unique order id
    uint256 internal _orderSequence = 0;
    // @notice Number of decimals for conversion of all integer values type decimals
    uint64 public decimals;

    // @notice Mapping of orderKey(evm) to orders pending processing by carbon
    mapping(string => Order) public pendingOrders;

    // @notice Mapping of account address to position query request
    mapping(address => PositionQuery) public positionQueries;
    // @notice Mapping of orderKey to order query request
    mapping(string => OrderQuery) public orderQueries;
    // @notice Mapping of orderKey to callback request for update after order processed
    mapping(string => OrderQuery) public orderCreationCallback;

    // =============Events================
    // @param creator - evm address of the order creator
    // @param market - market name of the order
    // @param side - side of the order in uint8
    // @param price - price of the order to be converted from int to dec
    // @param quantity - quantity of the order to be converted from int to dec
    // @param status - status of the order in uint8
    // @param orderType - order type of the order in uint8
    // @param timeInForce - time in force of the order in uint8
    // @param isReduceOnly - reduce only flag of the order
    // @param decimals - number of decimals for conversion of all int to dec
    // @param contractId - id of the contract for carbon to track the contract to update
    event CreateOrder(
        string orderKey,
        address creator,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        bool isReduceOnly,
        uint64 decimals,
        string contractId
    );

    // @notice event to update the finalised order details as a back up for callback
    // @param orderKey - evmKey of the order
    // @param order - update order after processed by carbon broker
    event FinalisedOrder(string orderKey, Order order);

    // @notice event for position query request to carbon
    // @param market - market name the position is in
    // @param account - evm address of the position's account
    // @param contractId - id of the contract for carbon to track the contract to update
    event PositionQueryRequest(
        string market,
        address accountAddress,
        string contractId
    );

    // @notice event for position query response as a back up for callback
    event PositionQueryResponse(MsgPositionQueryRes msg);

    // @param orderKey - evmKey of the order
    // @param order - order that has failed and not processed by carbon broker
    // @param error - error message from evm integration of order module
    event OrderError(string orderKey, Order errOrder, string error);

    constructor(string memory contractId_, uint64 decimals_) {
        contractId = contractId_;
        decimals = decimals_;
    }

    // @notice generates a new FOK order to be relayed to carbon broker
    // @dev emits a create order event captured by order module of carbon
    // @params market_ - market name the order is to
    // @params side_ - side of the order in uint8
    // @params quantity_ - quantity of the order
    // @params orderType_ - limit or market order in uint8
    // @params price_ - price of the order
    // @params isReduceOnly_ - reduce only flag of the order
    // @params callbackSig_ - signature of the callback function of the client's contract for updating of processed order
    function createOrder(
        string calldata market_,
        Side side_,
        uint256 quantity_,
        OrderType orderType_,
        uint256 price_,
        bool isReduceOnly_,
        string calldata callbackSig_
    ) external whenNotPaused {
        require(tx.origin != owner(), "Owner cannot create order"); // Prevent tx.origin exploit

        Order memory newOrder;
        string memory orderKey = generateOrderKey();

        address creator_ = tx.origin; // to use tx.origin or _msg.Sender? //dklog

        newOrder.id = ""; // This is the id generated by carbon
        newOrder.evmCreator = creator_;
        newOrder.market = market_;
        newOrder.side = side_;
        newOrder.price = price_;
        newOrder.quantity = quantity_;
        newOrder.status = Status.Pending;
        newOrder.orderType = orderType_;
        newOrder.timeInForce = TimeInForce.GTC; //! DKLOG for testing change back to FOK
        newOrder.isReduceOnly = isReduceOnly_;

        // add the order into the mapping
        pendingOrders[orderKey] = newOrder;

        // add to the callback map if signature is provided
        if (bytes(callbackSig_).length > 0) {
            // order id field is irrelevant here
            orderCreationCallback[orderKey] = OrderQuery(
                _msgSender(),
                callbackSig_
            );
        }

        emit CreateOrder(
            orderKey,
            creator_,
            newOrder.market,
            newOrder.side,
            newOrder.price,
            newOrder.quantity,
            newOrder.status,
            newOrder.orderType,
            newOrder.timeInForce,
            newOrder.isReduceOnly,
            decimals,
            contractId
        );
    }

    // @notice process the order updates either via callback or event
    // @dev emits a finalised order event if callback fn not provided or failed
    function updateOrderStatus(
        string calldata orderKey,
        string calldata orderId_,
        uint256 avgFilledPrice_,
        Status status_
    ) internal onlyOwner whenNotPaused returns (bool error) {
        // Get the pending order
        Order storage order = pendingOrders[orderKey];
        if (order.quantity == 0) {
            return true;
        }

        // Update the pending order and emit the finalised order details
        order.avgFilledPrice = avgFilledPrice_;
        order.id = orderId_;
        order.status = status_;

        // Callback to the caller or emit finalised order event
        orderCallback(order, orderKey);
        // Remove pending order from the store
        delete pendingOrders[orderKey];
        return false;
    }

    // @notice batch update call made by carbon broker to update all processed orders
    function updateAllOrdersStatus(
        MsgOrderUpdate[] calldata orderUpdates_
    ) external onlyOwner whenNotPaused returns (string memory error) {
        for (uint i = 0; i < orderUpdates_.length; i += 1) {
            bool err = updateOrderStatus(
                orderUpdates_[i].orderKey,
                orderUpdates_[i].orderId,
                orderUpdates_[i].avgFilledPrice,
                orderUpdates_[i].status
            );
            if (err) {
                return "Order could not be updated";
            }
        }
        return "";
    }

    // @dev emits finalised order, extracted due to stack limitation
    function emitFinalOrder(
        Order memory order,
        string calldata orderKey
    ) internal {
        emit FinalisedOrder(orderKey, order);
    }

    // @notice encodes the update and makes the callback to the client contract
    function orderCallback(
        Order storage order,
        string calldata orderKey
    ) internal {
        bool noEmitEvent = false;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                order,
                orderKey
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey];
        }

        if (!noEmitEvent) {
            emitFinalOrder(order, orderKey);
        }
    }

    // @notice delete the pending order in the event of an error before carbon processes
    // the order. Proceeds to callback or emit event with updates.
    function deleteErrOrder(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner whenNotPaused {
        bool noEmitEvent = false;
        // purge the pending order and update with unprocessed status
        Order storage errOrder = pendingOrders[orderKey_];
        delete pendingOrders[orderKey_];
        errOrder.status = Status.Unprocessed;

        // Check for callback request
        OrderQuery memory req = orderCreationCallback[orderKey_];
        if (bytes(req.fnSigature).length > 0) {
            // Send the full order back to the caller or emit event on failure
            bytes memory encodedCall = abi.encodeWithSignature(
                req.fnSigature,
                errOrder,
                orderKey_
            );
            (noEmitEvent, ) = req.caller.call(encodedCall);

            delete orderCreationCallback[orderKey_];
        }

        if (!noEmitEvent) {
            emit OrderError(orderKey_, errOrder, error_);
        }
    }

    // @notice registers the position query request from the client and saves the required details
    // @param accountAddress_ - evm address of the position to query
    // @param market_ - market name of the position to query
    // @param callbackSig_ - signature of the callback function to return response
    function queryAddressPosition(
        address accountAddress_,
        string calldata market_,
        string calldata callbackSig_
    ) external whenNotPaused {
        PositionQuery memory positionQuery;
        positionQuery.market = market_;
        positionQuery.caller = _msgSender();
        positionQuery.fnSigature = callbackSig_;

        positionQueries[accountAddress_] = positionQuery;
        emit PositionQueryRequest(market_, accountAddress_, contractId);
    }

    // @notice Called by carbon to relay the response after processing query
    function respondToPositionQuery(
        MsgPositionQueryRes calldata msg_
    ) external onlyOwner whenNotPaused {
        PositionQuery memory queryReq = positionQueries[msg_.evmAddress];
        bool noEmitEvent = true;
        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                msg_
            );

            // no need return value of call since it is a fire and forget but send an event so the caller
            // can still check for the position in another way
            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }
        if (!noEmitEvent) {
            emit PositionQueryResponse(msg_);
        }
        positionQueries[msg_.evmAddress] = queryReq;
        // remove the query from the store
        delete positionQueries[msg_.evmAddress];
    }

    // @notice registers the order query request from the client and saves the required details
    // @dev mapping of the evm orderKey is persisted in the store of carbon
    // @param orderKey_ - evm key of the order to query
    // @param callbackSig_ - signature of the callback function to return response
    function queryOrder(
        string calldata orderKey_,
        string calldata callbackSig_
    ) external whenNotPaused {
        OrderQuery memory orderQuery;
        orderQuery.caller = _msgSender();
        orderQuery.fnSigature = callbackSig_;

        orderQueries[orderKey_] = orderQuery;
    }

    // @notice Called by carbon to relay the order response after processing query
    function respondToOrderQuery(
        MsgOrderQueryResponse memory msg_
    ) external whenNotPaused onlyOwner {
        OrderQuery memory queryReq = orderQueries[msg_.orderKey];

        // check if there is a callback provided
        bool noEmitEvent = true;
        if (bytes(queryReq.fnSigature).length > 0) {
            bytes memory encodedCall = abi.encodeWithSignature(
                queryReq.fnSigature,
                msg_.order,
                msg_.orderKey
            );

            (noEmitEvent, ) = queryReq.caller.call(encodedCall);
        }
        if (!noEmitEvent) {
            emit FinalisedOrder(msg_.orderKey, msg_.order);
        }
        delete orderQueries[msg_.orderKey];
    }

    // @notice Hash function to generate a uuid for the order
    // @dev  Uses a combination of contractId and order seq number within the contract
    function generateOrderKey() private returns (string memory) {
        bool isCollision = true;
        string memory stringId;
        // generate hashId until no collisions found
        while (isCollision) {
            bytes memory bz = abi.encodePacked(contractId, _orderSequence);
            bytes32 hashedId = keccak256(bz);
            stringId = Strings.toHexString(uint256(hashedId), 32);
            isCollision = false;

            // Check existing pending store for key collisions
            Order memory existingOrder = pendingOrders[stringId];
            if (existingOrder.status != Status.Unprocessed) {
                isCollision = true;
            }
        }
        _orderSequence += 1;
        return stringId;
    }

    //Trial functions - sanity check
    function updateTestNumber(address evmAddr, uint8 testNumber_) external {
        // PositionQuery memory query = positionQueries[evmAddr];
        // console.log("relayer", testNumber_);
        // // This works must be exact name of function
        // query.caller.call(
        //     abi.encodeWithSignature(query.fnSigature, testNumber_)
        // );
    }

    function ping() public pure returns (string memory) {
        return "pong";
    }
}
