// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./@openzeppelin/contracts/utils/Strings.sol";
import "./@openzeppelin/contracts/utils/structs/EnumerableMap.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./@openzeppelin/contracts/security/Pausable.sol";

contract OrdersRelayer is Ownable, Pausable {
    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;

    struct Position {
        string market;
        string accountAddress;
        int256 lots;
        uint256 entryPrice;
        int256 realisedPnl;
        string marginDenom;
        uint256 marginAmount;
        uint256 openBlockHeight;
    }

    struct Order {
        string id;
        string market;
        Side side;
        uint256 price;
        uint256 quantity; // Originally int will have extra decimal zeros
        Status status;
        OrderType orderType;
        TimeInForce timeInForce;
        uint256 avgFilledPrice;
        bool isReduceOnly;
        address evmCreator; // evm address of the creator
    }

    struct MsgOrderUpdate {
        string orderKey;
        string OrderId;
        uint256 avgFilledPrice;
        Status Status;
    }

    struct MsgPositionUpdate {
        string Market;
        string AccountAddress;
        int256 Lots;
        uint256 EntryPrice;
        int256 RealisedPnl;
        string MarginDenom;
        uint256 MarginAmount;
        uint256 OpenBlockHeight;
    }

    enum Status {
        Nil,
        Pending,
        Closed,
        Cancelled,
        Open
    }

    enum TimeInForce {
        FOK,
        GTC,
        IOC
    }

    enum Side {
        Buy,
        Sell
    }

    enum OrderType {
        Limit,
        Market
    }

    string public contractId;
    uint256 internal _orderSequence = 0;
    uint64 public decimals;

    // OrderId is the key for the map
    // stores the pending order for info until updates are provided by carbon
    // can consider not having a mapping since successfully relayed
    // orders emit an event but map used to check for id collision
    mapping(string => Order) public pendingOrders;

    // Position mapping to store the positions of users
    // EVM address(key) -> Position (value) carbon address within
    mapping(address => Position) public positions;
    EnumerableMap.Bytes32ToUintMap internal _positionRecord;
    //=============Events================
    event Test(string log); // dklog

    event CreateOrder(
        string orderKey,
        address creator,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        bool isReduceOnly,
        uint64 decimals,
        string contractId
    );

    // carbon address fields removed from event as stack too deep
    event FinalisedOrder(
        string orderKey,
        string id,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        uint256 avgFilledPrice,
        bool isReduceOnly,
        address evmCreator
    );

    // order error event to inform that the order is not processed by carbon
    event OrderError(string orderKey, string error);

    constructor(string memory contractId_, uint64 decimals_) {
        contractId = contractId_;
        decimals = decimals_;
    }

    // Hash functions to generate a uuid for the order using a combination of contractId
    // and running sequence number within the contract
    function generateOrderKey() public returns (string memory) {
        bool isCollision = true;
        string memory stringId;
        // generate hashId until no collisions found
        while (isCollision) {
            bytes memory bz = abi.encodePacked(contractId, _orderSequence);
            bytes32 hashedId = keccak256(bz);
            stringId = Strings.toHexString(uint256(hashedId), 32);
            isCollision = false;

            // Check existing pending store for key collisions
            Order memory existingOrder = pendingOrders[stringId];
            if (existingOrder.status != Status.Nil) {
                isCollision = true;
            }
        }
        _orderSequence += 1;
        return stringId;
    }

    // createOrder - generates a new FOK order to be store in the contract and relayed to carbon
    // Creator is not the msg.sender as the sender can be a relayer contract
    function createOrder(
        address creator_,
        string calldata market_,
        Side side_,
        uint256 quantity_,
        OrderType orderType_,
        uint256 price_,
        bool isReduceOnly_
    ) external whenNotPaused {
        Order memory newOrder;
        string memory orderKey = generateOrderKey();

        newOrder.id = ""; // This is the id generated by carbon
        newOrder.evmCreator = creator_;
        newOrder.market = market_;
        newOrder.side = side_;
        newOrder.price = price_;
        newOrder.quantity = quantity_;
        newOrder.status = Status.Pending;
        newOrder.orderType = orderType_;
        newOrder.timeInForce = TimeInForce.GTC;
        newOrder.isReduceOnly = isReduceOnly_;

        // add the order into the mapping
        pendingOrders[orderKey] = newOrder;

        // emitted event to carbon for order creation
        emit CreateOrder(
            orderKey,
            creator_,
            newOrder.market,
            newOrder.side,
            newOrder.price,
            newOrder.quantity,
            newOrder.status,
            newOrder.orderType,
            newOrder.timeInForce,
            newOrder.isReduceOnly,
            decimals,
            contractId
        );
    }

    // updateOrderStatus - receives the finalised order from carbon and broadcast the finalised order
    function updateOrderStatus(
        string calldata orderKey,
        string calldata orderId_,
        uint256 avgFilledPrice_,
        Status status_
    ) public onlyOwner whenNotPaused returns (bool error) {
        // Get the pending order
        Order storage order = pendingOrders[orderKey];
        if (order.quantity == 0) {
            return true;
        }

        // Update the pending order and emit the finalised order details
        order.avgFilledPrice = avgFilledPrice_;
        order.id = orderId_;
        order.status = status_;

        // Remove pending order from the store
        // delete pendingOrders[orderKey]; dklog
        pendingOrders[orderKey] = order;
        return false;
    }

    function updateAllOrdersStatus(
        MsgOrderUpdate[] calldata orderUpdates_
    ) external onlyOwner whenNotPaused returns (string memory error) {
        for (uint i = 0; i < orderUpdates_.length; i += 1) {
            bool err = updateOrderStatus(
                orderUpdates_[i].orderKey,
                orderUpdates_[i].OrderId,
                orderUpdates_[i].avgFilledPrice,
                orderUpdates_[i].Status
            );
            if (err) {
                return "Order could not be updated";
            }
        }
        return "";
    }

    function emitFinalOrder(
        Order calldata order,
        string calldata orderKey
    ) internal {
        emit FinalisedOrder(
            orderKey,
            order.id,
            order.market,
            order.side,
            order.price,
            order.quantity,
            order.status,
            order.orderType,
            order.timeInForce,
            order.avgFilledPrice,
            order.isReduceOnly,
            order.evmCreator
        );
    }

    // deleteErrOrder - deletes the pending order that has been validated to be erroneous by carbon and emits an error event
    function deleteErrOrder(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner whenNotPaused {
        // purge the pending order from the store as it will not be processed by carbon
        delete pendingOrders[orderKey_];
        emit OrderError(orderKey_, error_);
    }

    //todo: function to update all positions kept in state
    //? consider array or receive a struct ?
    //? how will carbon know what positions to be sending to evm?
    //? track based on the order sent / updated from carbon and send the position together?
    function updatePositions(
        address EVMAddress_,
        Position memory incomingPosition_
    ) external onlyOwner whenNotPaused {
        Position memory position;
        position = incomingPosition_;
        positions[EVMAddress_] = position;
    }

    // updatePositionRecord - check if the contract should request for position updates for this user
    function updateAllPosition(
        MsgPositionUpdate[] calldata positionUpdates_
    ) internal {
        // check for futures order
    }

    function ping() public pure returns (string memory) {
        return "pong";
    }
}
