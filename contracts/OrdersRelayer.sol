// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./@openzeppelin/contracts/utils/Strings.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./@openzeppelin/contracts/security/Pausable.sol";

contract OrdersRelayer is Ownable, Pausable {
    // Commented order fields cannot be added due to stack limitation
    // 12 fields for the local stored map
    struct Order {
        string id;
        string carbonCreator; // mapped carbon address of the creator
        string market;
        Side side;
        uint256 price;
        uint256 quantity; // Originally int will have extra decimal zeros
        Status status;
        OrderType orderType;
        TimeInForce timeInForce;
        uint256 avgFilledPrice;
        bool isReduceOnly;
        address evmCreator; // evm address of the creator
    }

    enum Status {
        Nil,
        Pending,
        Closed,
        Cancelled
    }

    enum TimeInForce {
        FOK,
        GTC,
        IOC
    }

    enum Side {
        Buy,
        Sell
    }

    enum OrderType {
        Limit,
        Market
    }

    string public contractId;
    uint256 internal _orderSequence = 0;
    uint64 public decimals;

    // OrderId is the key for the map
    // stores the pending order for info until updates are provided by carbon
    // can consider not having a mapping since successfully relayed
    // orders emit an event but map used to check for id collision
    mapping(string => Order) public pendingOrders;

    event Test(string log);
    //=============Events================
    event CreateOrder(
        string orderKey,
        address creator,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        bool isReduceOnly,
        uint64 decimals,
        string contractId
    );

    // address fields removed from event as stack too deep
    event FinalisedOrder(
        string orderKey,
        string id,
        string market,
        Side side,
        uint256 price,
        uint256 quantity,
        Status status,
        OrderType orderType,
        TimeInForce timeInForce,
        uint256 avgFilledPrice,
        bool isReduceOnly,
        address evmCreator
    );

    event OrderError(string orderKey, string error);

    constructor(string memory contractId_, uint64 decimals_) {
        contractId = contractId_;
        decimals = decimals_;
    }

    // Hash functions to generate a uuid for the order using a combination of contractId
    // and running sequence number within the contract
    function generateOrderKey() public returns (string memory) {
        bool isCollision = true;
        string memory stringId;
        // generate hashId until no collisions found
        while (isCollision) {
            bytes memory bz = abi.encodePacked(contractId, _orderSequence);
            bytes32 hashedId = keccak256(bz);
            stringId = Strings.toHexString(uint256(hashedId), 32);
            isCollision = false;

            // Check existing pending store for key collisions
            Order memory existingOrder = pendingOrders[stringId];
            if (existingOrder.status != Status.Nil) {
                isCollision = true;
            }
        }
        _orderSequence += 1;
        return stringId;
    }

    // CreateOrder - generates a new FOK order to be store in the contract and relayed to carbon
    // Creator is not the msg.sender as the sender can be a relayer contract
    function createOrder(
        address creator_,
        string calldata market_,
        Side side_,
        uint256 quantity_,
        OrderType orderType_,
        uint256 price_,
        bool isReduceOnly_
    ) external whenNotPaused {
        Order memory newOrder;
        string memory orderKey = generateOrderKey();

        newOrder.id = ""; // This is the id generated by carbon
        newOrder.evmCreator = creator_;
        newOrder.market = market_;
        newOrder.side = side_;
        newOrder.price = price_;
        newOrder.quantity = quantity_;
        newOrder.status = Status.Pending;
        newOrder.orderType = orderType_;
        newOrder.timeInForce = TimeInForce.FOK; //! dklog test gtc and check that the order exist
        newOrder.isReduceOnly = isReduceOnly_;

        // add the order into the mapping
        pendingOrders[orderKey] = newOrder;

        // emitted event to carbon for order creation
        emit CreateOrder(
            orderKey,
            creator_,
            newOrder.market,
            newOrder.side,
            newOrder.price,
            newOrder.quantity,
            newOrder.status,
            newOrder.orderType,
            newOrder.timeInForce,
            newOrder.isReduceOnly,
            decimals,
            contractId
        );
    }

    // updatePendingOrder - receives the finalised order from carbon and broadcast the finalised order
    function updatePendingOrder(
        string calldata orderKey,
        string calldata orderId_,
        string calldata carbonAddr_,
        uint256 avgFilledPrice_,
        Status status_
    ) external onlyOwner whenNotPaused returns (string memory error) {
        // Get the pending order
        Order memory pendingOrder = pendingOrders[orderKey];
        if (pendingOrder.quantity == 0) {
            return "Pending order cannot be found";
        }

        // Update the pending order and emit the finalised order details
        pendingOrder.avgFilledPrice = avgFilledPrice_;
        pendingOrder.id = orderId_;
        pendingOrder.carbonCreator = carbonAddr_;
        pendingOrder.status = status_;

        // Remove pending order from the store
        delete pendingOrders[orderKey];
        emit Test("cycle completed");
    }

    function emitFinalOrder(
        Order calldata order,
        string calldata orderKey
    ) internal {
        emit FinalisedOrder(
            orderKey,
            order.id,
            order.market,
            order.side,
            order.price,
            order.quantity,
            order.status,
            order.orderType,
            order.timeInForce,
            order.avgFilledPrice,
            order.isReduceOnly,
            order.evmCreator
        );
    }

    function ping() public pure returns (string memory) {
        return "pong";
    }

    function pendingOrderErr(
        string calldata orderKey_,
        string calldata error_
    ) external onlyOwner whenNotPaused {
        // purge the pending order from the store as it was not processed by carbon
        delete pendingOrders[orderKey_];
        emit OrderError(orderKey_, error_);
    }

    //todo: cancel order
    //todo: edit order
}
